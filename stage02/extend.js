// 1. 原型链继承
`将父构造函数的实例，赋值给 子构造函数的原型对象`
`Son.prototype = new Father()`
缺点`子实例之间的操作会互相影响，且父构造函数的属性也会被影响`


// 2. 借用构造函数继承
`子构造函数中，调用父类构造函数 并 call(this)`
`function Son() {
    Father.call(this)
}`
缺点`1.只能继承父类的实例属性和方法，不能继承原型属性和方法 2. 无法实现复用，每个子类都有父类实例函数的副本，影响性能`

// 3. 组合继承
`用原型链继承实现对原型属性和方法的继承，用构造函数继承来实现实例属性的继承`
`function Son() {
    Father.call(this)
}`
`Son.prototype = new Father()`
`Son.prototype.constructor = SubType` 
缺点`子类创建实例时，其原型中会存在两份相同的属性和方法`
// 4. 原型式继承
Object.create()
// 5.寄生式继承
// 核心：原型式继承基础上，增强对象，返回构造函数
// 原型式继承基础上，增强对象，返回构造函数【主要作用，是为构造函数新增属性和方法】
缺点`原型链继承多个实例的引用类型属性指向相同，存在篡改可能； 无法传递参数`

// 6. 寄生组合式继承
// 寄生式继承+构造函数传递参数
// 7. mixin继承（多继承）

// 8. extends
// 子类构造函数中必须调用super函数。 super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类；

